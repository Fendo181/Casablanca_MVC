<?php

/*
インターフェイスの定義
インターフェイスとは異なる、クラスに共通の機能を実装するためにその実態を定義することなく指定する仕組みです??
・インターフェイスのメソッドは必ずpublicでなければなりません!
・また、インターフェイスの定義には実態のあるメソッドは定義できません。
このインターネットを実装するクラスで実装しなければいけないメソッドを定義します。

インターフェイスをクラスに実装する場合はimprmentsキーワードを使います。

クラスから"ユーザー定義型"の能力のみを分離した言語機構です。PHPのそれはJavaのinterfaceのパクリです。

interfaceはそれ単独では役に立ちません。もっぱら、タイプヒンティングと組み合わせて使います。タイプヒンティングに使われていないinterfaceがソースコード中に出現したら、「お前は何がしたいんだ」とレビューコメントに書いてOKです。(正確には他にも使い道があるのですが、ややこしくなるので一旦そういうことにしておいてください)

つまる所インターフェイスを実装する利点としては、定義したメソッドがちゃんとうまく動作する為のチェック(タイピング目的)である。

つまりはこれが型を決める的な?

http://blog.tojiru.net/article/377526320.html
ここのまとめ素晴らし

両者がインターフェースを要求したとします。すると、二つのインターフェースを実装した一つのクラスを作るだけで済みます。クラスが一個ということはインスタンスも一つでよいので、インスタンスの管理も単純明快です。基底クラスはテンプレートエンジンの側のクラスを使うことができるので、実装も簡単になります。

PHPのクラスは単一継承しか許されていません。クラスでタイプヒンティングするということは、そのクラスか、もしくは派生クラスを要求するということです。これは実は、非常に厳しい制約です。インターフェースの場合は単一継承の制約を受けないため、制約が緩くなります。

まとめ
というわけで、タイプヒンティングでクラスではなくインターフェースを要求することで、謙虚で組み合わせやすいライブラリが作れて、しかも型による（ある程度の）品質保証ができます。無闇にクラスを要求するのは不作法なのでやめましょう。
*/

interface FooInterface
{
    const MOGE =1;
    public function doSomething1();
    public function doSomething2(DateTime $date);
}



//ここで実体のある処理を記述する。
class Foo implements FooInterface
{
    public function doSomething1()
    {
        //書き込み処理
    }
    
    public function doSomething2(DateTime $date)
    {
        //読み込み処理
    }
    
}
/*
$foo instanceof FooInterface を満たしていない$fooを渡した場合、このuseFoo()関数を実行するとエラーが発生してPHPが停止します。動的検査なので効果は限定的ですが、カバレッジ100%のユニットテストと組み合わせれば早期にプログラムの問題に気づくことができるでしょう。
*/

function useFoo(FooInterface $foo)
{
    $foo ->doSomething1();
    $foo ->doSomething2(new Datetime);
}


?>